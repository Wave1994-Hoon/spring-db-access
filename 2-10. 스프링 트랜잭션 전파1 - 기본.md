## 스프링 트랜잭션 전파 1

### 1. 시작 전, 로깅 설정 추가
```
logging.level.org.springframework.transaction.interceptor=TRACE
logging.level.org.springframework.jdbc.datasource.DataSourceTransactionManager=DEBUG 

#JPA log
logging.level.org.springframework.orm.jpa.JpaTransactionManager=DEBUG
logging.level.org.hibernate.resource.transaction=DEBUG

#JPA SQL
logging.level.org.hibernate.SQL=DEBUG
```

<br>

### 2. 트랜잭션 두 번 사용
```java
@Test
void double_commit() {
  log.info("트랜잭션1 시작");
  TransactionStatus tx1 = txManager.getTransaction(new DefaultTransactionAttribute());
  
  log.info("트랜잭션1 커밋"); 
  txManager.commit(tx1);
  
  log.info("트랜잭션2 시작");
  TransactionStatus tx2 = txManager.getTransaction(new DefaultTransactionAttribute());
  
  log.info("트랜잭션2 커밋");
  txManager.commit(tx2);
}
```

#### 트랜잭션 1
트랜잭션1을 시작하고, 커넥션 풀에서 `conn0` 커넥션을 획득했다.

```
Acquired Connection [HikariProxyConnection@1064414847 wrapping conn0] for JDBC transaction
```


트랜잭션1을 커밋하고, 커넥션 풀에 `conn0` 커넥션을 반납했다.

```
Releasing JDBC Connection [HikariProxyConnection@1064414847 wrapping conn0] after transaction
```

#### 트랜잭션 2
트랜잭션2을 시작하고, 커넥션 풀에서 `conn0` 커넥션을 획득했다.

```
Acquired Connection [HikariProxyConnection@ 778350106 wrapping conn0] for JDBC transaction
```

트랜잭션2을 커밋하고, 커넥션 풀에 `conn0` 커넥션을 반납했다.

```
Releasing JDBC Connection [HikariProxyConnection@ 778350106 wrapping conn0] after transaction
```

#### 주의
로그를 보면 트랜잭션1과 트랜잭션2가 같은 `conn0` 커넥션을 사용중이다.

같은 커넥션을 사용하는 이유는 커넥션 풀 때문이다.

다시 정리하자면, 트랜잭션 1은 `conn0` 커넥션을 모두 사용하고 커넥션 풀에 반납까지 완료하였다.

이후에 트랜잭션2가 `conn0` 를 커넥션 풀에서 획득한 것이다.

따라서 둘은 다른 커넥션으로 인지하는 것이 맞다.

#### 커넥션 구분 ?
Hikari CP 에서 커넥션을 획득하면 실제 커넥션을 그대로 반환하는 것이 아니라 

내부 관리를 위해 Hikari proxy connection 객체를 생성해서 반환단다.

내부에는 실제 커넥션이 포함되어 있다.

```
Acquired Connection [HikariProxyConnection@1000000 wrapping conn0] // 트랜잭션 1
Acquired Connection [HikariProxyConnection@2000000 wrapping conn0] // 트랜잭션 2
```

#### 정리
![image](https://user-images.githubusercontent.com/60383031/184167427-1d3b1040-8117-4652-bac5-63c9eb69ee42.png)

- 트랜잭션이 각각 수행되면서 사용되는 DB 커넥션도 다른다.

<br>

### 3. 스프링 트랜잭션 전파3 - 전파 기본
![image](https://user-images.githubusercontent.com/60383031/184468941-764a8654-fbc0-4d86-acc5-ee76cbc6ce98.png)

트랜잭션 전파(propagation) 기본 옵션인 REQUIRED 를 사용하면 스프링은 외부 트랜잭션과 내부 트랜잭션을 묶어서 하나의 트랜잭션을 만들어준다.

내부 트랜잭션이 외부 트랜잭션에 참여하는 것이다. 이것이 기본 동작이고, 옵션을 통해 다른 동작방식도 선택할 수 있다.


#### 논리, 물리 트랜잭션
![image](https://user-images.githubusercontent.com/60383031/184469071-d5e263b3-2a36-46e9-bc0a-6d72a445d1c1.png)

- 논리 트랜잭션: 하나의 물리 트랜잭션으로 묶인다
  - 트랜잭션 매니저를 통해 트랜잭션을 사용하는 단위이다

 
- 물리 트랜잭션: 실제 데이터베이스에 적용되는 트랜잭션을 뜻한다.
  - 실제 커넥션을 통해서 트랜잭션을 시작(setAutoCommit(false)) 하고, 실제 커넥션을 통해서 커밋, 롤백하는 단위
 

- 원칙: 모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋된다. 하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션은 롤백된다.
 

<br>

### 4. 스프링 트랜잭션 전파4 - 전파 예제

```java
@Test
void inner_commit() {
  log.info("외부 트랜잭션 시작");
  TransactionStatus outer = txManager.getTransaction(new DefaultTransactionAttribute());
  log.info("outer.isNewTransaction()={}", outer.isNewTransaction());
  
  log.info("내부 트랜잭션 시작");
  TransactionStatus inner = txManager.getTransaction(new DefaultTransactionAttribute());
  log.info("inner.isNewTransaction()={}", inner.isNewTransaction()); 
  
  log.info("내부 트랜잭션 커밋");    
  txManager.commit(inner);
  
  log.info("외부 트랜잭션 커밋");
  txManager.commit(outer);
}
```

