## 스프링 트랜잭션 전파 1

### 시작 전, 로깅 설정 추가
```
logging.level.org.springframework.transaction.interceptor=TRACE
logging.level.org.springframework.jdbc.datasource.DataSourceTransactionManager=DEBUG 

#JPA log
logging.level.org.springframework.orm.jpa.JpaTransactionManager=DEBUG
logging.level.org.hibernate.resource.transaction=DEBUG

#JPA SQL
logging.level.org.hibernate.SQL=DEBUG
```

### 트랜잭션 두 번 사용
```java
@Test
void double_commit() {
  log.info("트랜잭션1 시작");
  TransactionStatus tx1 = txManager.getTransaction(new DefaultTransactionAttribute());
  
  log.info("트랜잭션1 커밋"); 
  txManager.commit(tx1);
  
  log.info("트랜잭션2 시작");
  TransactionStatus tx2 = txManager.getTransaction(new DefaultTransactionAttribute());
  
  log.info("트랜잭션2 커밋");
  txManager.commit(tx2);
}
```

#### 트랜잭션 1
트랜잭션1을 시작하고, 커넥션 풀에서 `conn0` 커넥션을 획득했다.

```
Acquired Connection [HikariProxyConnection@1064414847 wrapping conn0] for JDBC transaction
```


트랜잭션1을 커밋하고, 커넥션 풀에 `conn0` 커넥션을 반납했다.

```
Releasing JDBC Connection [HikariProxyConnection@1064414847 wrapping conn0] after transaction
```

#### 트랜잭션 2
트랜잭션2을 시작하고, 커넥션 풀에서 `conn0` 커넥션을 획득했다.

```
Acquired Connection [HikariProxyConnection@ 778350106 wrapping conn0] for JDBC transaction
```

트랜잭션2을 커밋하고, 커넥션 풀에 `conn0` 커넥션을 반납했다.

```
Releasing JDBC Connection [HikariProxyConnection@ 778350106 wrapping conn0] after transaction
```

#### 주의
로그를 보면 트랜잭션1과 트랜잭션2가 같은 `conn0` 커넥션을 사용중이다.

같은 커넥션을 사용하는 이유는 커넥션 풀 때문이다.

다시 정리하자면, 트랜잭션 1은 `conn0` 커넥션을 모두 사용하고 커넥션 풀에 반납까지 완료하였다.

이후에 트랜잭션2가 `conn0` 를 커넥션 풀에서 획득한 것이다.

따라서 둘은 다른 커넥션으로 인지하는 것이 맞다.

#### 커넥션 구분 ?
Hikari CP 에서 커넥션을 획득하면 실제 커넥션을 그대로 반환하는 것이 아니라 

내부 관리를 위해 Hikari proxy connection 객체를 생성해서 반환단다.

내부에는 실제 커넥션이 포함되어 있다.

```
Acquired Connection [HikariProxyConnection@1000000 wrapping conn0] // 트랜잭션 1
Acquired Connection [HikariProxyConnection@2000000 wrapping conn0] // 트랜잭션 2
```

#### 정리
![image](https://user-images.githubusercontent.com/60383031/184167427-1d3b1040-8117-4652-bac5-63c9eb69ee42.png)

- 트랜잭션이 각각 수행되면서 사용되는 DB 커넥션도 다른다.



